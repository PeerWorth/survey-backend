name: Deploy to Production Environment

on:
  pull_request:
    types: [closed]
    branches:
      - main

jobs:
  deploy:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    env:
      GH_PAT: ${{ secrets.GH_PAT }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Bump version from latest tag (supports #major #minor)
        id: versioning
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          # 먼저 인증된 remote로 덮어쓰기
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"

          git config --unset-all http.https://github.com/.extraheader || true

          git remote set-url origin https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git

          # 이후 fetch는 PAT 인증 기반으로 수행됨
          git fetch --tags

          # 최신 태그 추출 (prod 태그 필터링)
          LATEST_TAG=$(git tag -l "v*" --sort=-version:refname | head -n 1)

          # 태그가 없으면 초기값 설정
          if [ -z "$LATEST_TAG" ]; then
            echo "No existing prod tags found. Starting from v0.0.0"
            LATEST_TAG="v0.0.0"
          fi

          VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          # 버전 구성요소가 비어있으면 0으로 설정
          MAJOR=${MAJOR:-0}
          MINOR=${MINOR:-0}
          PATCH=${PATCH:-0}

          echo "📌 Current version: v$MAJOR.$MINOR.$PATCH"

          # PR 제목에서 버전 증가 타입 확인
          PR_TITLE="${{ github.event.pull_request.title }}"
          echo "🔍 PR title: $PR_TITLE"

          # 증가 타입 판별
          if [[ "$PR_TITLE" == *"#major"* ]]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            INCREMENT_TYPE="major"
          elif [[ "$PR_TITLE" == *"#minor"* ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
            INCREMENT_TYPE="minor"
          else
            PATCH=$((PATCH + 1))
            INCREMENT_TYPE="patch"
          fi

          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          echo "🎯 Bumping $INCREMENT_TYPE version: $LATEST_TAG → $NEW_VERSION"

          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "new_tag=$NEW_VERSION" >> $GITHUB_OUTPUT

          # 태그 생성 및 푸시
          git tag $NEW_VERSION
          git push origin $NEW_VERSION

      - name: Save .env
        run: echo "${{ secrets.PROD_ENV_CONTENTS }}" > .env

      - name: Change files for production environment
        run: cp docker-compose.prod.yml docker-compose.yml

      - name: Zip Application
        run: zip -r app.zip . -x ".git/*" ".github/*"

      - name: Upload to S3
        run: |
          aws s3 cp app.zip s3://${{ secrets.PROD_EB_BUCKET }}/app-${{ env.NEW_VERSION }}.zip

      - name: Verify EB environment is ready
        run: |
          echo "Verifying Elastic Beanstalk environment status..."
          ENV_STATUS=$(aws elasticbeanstalk describe-environments \
            --application-name ${{ secrets.PROD_EB_APPLICATION_NAME }} \
            --environment-names ${{ secrets.PROD_EB_ENV_NAME }} \
            --query "Environments[0].Status" \
            --output text 2>/dev/null || echo "NOT_FOUND")

          if [ "$ENV_STATUS" = "NOT_FOUND" ] || [ "$ENV_STATUS" = "None" ]; then
            echo "❌ Environment not found. Please run 'make apply-prod' first."
            exit 1
          fi

          echo "✅ Environment status: $ENV_STATUS"

      - name: Create new Elastic Beanstalk Application Version
        run: |
          aws elasticbeanstalk create-application-version \
            --application-name ${{ secrets.PROD_EB_APPLICATION_NAME }} \
            --version-label ${{ env.NEW_VERSION }} \
            --source-bundle S3Bucket=${{ secrets.PROD_EB_BUCKET }},S3Key=app-${{ env.NEW_VERSION }}.zip

      - name: Deploy to Elastic Beanstalk
        run: |
          echo "🚀 Deploying new version to Production Elastic Beanstalk..."
          aws elasticbeanstalk update-environment \
            --environment-name ${{ secrets.PROD_EB_ENV_NAME }} \
            --version-label ${{ env.NEW_VERSION }}

      - name: Wait for deployment completion
        run: |
          echo "⏳ Waiting for deployment to complete..."

          # 최대 20분 대기 (80 * 15 = 1200초 = 20분)
          MAX_ATTEMPTS=80
          ATTEMPT=0

          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ENV_STATUS=$(aws elasticbeanstalk describe-environments \
              --environment-names ${{ secrets.PROD_EB_ENV_NAME }} \
              --query "Environments[0].Status" \
              --output text)

            ENV_HEALTH=$(aws elasticbeanstalk describe-environments \
              --environment-names ${{ secrets.PROD_EB_ENV_NAME }} \
              --query "Environments[0].Health" \
              --output text)

            echo "Status: $ENV_STATUS, Health: $ENV_HEALTH"

            # Ready 상태이고 Updating이 아니면 완료
            if [ "$ENV_STATUS" = "Ready" ]; then
              echo "✅ Production deployment completed! Final health: $ENV_HEALTH"
              break
            fi

            # 심각한 오류 상태면 중단
            if [ "$ENV_STATUS" = "Terminating" ] || [ "$ENV_STATUS" = "Terminated" ]; then
              echo "❌ Environment is in error state: $ENV_STATUS"
              exit 1
            fi

            ATTEMPT=$((ATTEMPT + 1))
            echo "   Attempt $ATTEMPT/$MAX_ATTEMPTS - Waiting 15s..."
            sleep 15
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "⚠️  Deployment timeout after 20 minutes, but this is normal for initial deployments"
            echo "   Check AWS Console for deployment progress"
          fi

      - name: Post deployment comment
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GH_PAT }}
          script: |
            const { owner, repo } = context.repo;
            const run_id = context.runId;
            const run_url = `https://github.com/${owner}/${repo}/actions/runs/${run_id}`;

            const status = '${{ job.status }}';
            const emoji = status === 'success' ? '✅' : '❌';
            const message = status === 'success'
              ? `Production deployment completed successfully! 🚀 Version: ${{ env.NEW_VERSION }}`
              : 'Production deployment failed! ❌';

            // PR 이벤트일 때만 코멘트 작성
            if (context.eventName === 'pull_request') {
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.issue.number,
                  body: `${emoji} ${message}\n\n[View deployment logs](${run_url})`
                });
              } catch (error) {
                console.log('Failed to create comment:', error.message);
                // 코멘트 실패는 무시하고 진행
              }
            }
