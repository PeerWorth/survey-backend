name: Deploy to Dev Environment

on:
  pull_request:
    types: [closed]
    branches:
      - dev

jobs:
  deploy:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    env:
      GH_PAT: ${{ secrets.GH_PAT }}

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}

    - name: Bump version from latest tag (supports #major #minor)
      id: versioning
      env:
        GH_PAT: ${{ secrets.GH_PAT }}
      run: |
        # Î®ºÏ†Ä Ïù∏Ï¶ùÎêú remoteÎ°ú ÎçÆÏñ¥Ïì∞Í∏∞
        git config --global user.name "github-actions"
        git config --global user.email "github-actions@github.com"

        git config --unset-all http.https://github.com/.extraheader || true

        git remote set-url origin https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git

        # Ïù¥ÌõÑ fetchÎäî PAT Ïù∏Ï¶ù Í∏∞Î∞òÏúºÎ°ú ÏàòÌñâÎê®
        git fetch --tags

        # ÏµúÏã† ÌÉúÍ∑∏ Ï∂îÏ∂ú (dev ÌÉúÍ∑∏ ÌïÑÌÑ∞ÎßÅ)
        LATEST_TAG=$(git tag -l "dev-v*" --sort=-version:refname | head -n 1)

        # ÌÉúÍ∑∏Í∞Ä ÏóÜÏúºÎ©¥ Ï¥àÍ∏∞Í∞í ÏÑ§Ï†ï
        if [ -z "$LATEST_TAG" ]; then
          echo "No existing dev tags found. Starting from dev-v0.0.0"
          LATEST_TAG="dev-v0.0.0"
        fi

        VERSION=${LATEST_TAG#dev-v}
        IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

        # Î≤ÑÏ†Ñ Íµ¨ÏÑ±ÏöîÏÜåÍ∞Ä ÎπÑÏñ¥ÏûàÏúºÎ©¥ 0ÏúºÎ°ú ÏÑ§Ï†ï
        MAJOR=${MAJOR:-0}
        MINOR=${MINOR:-0}
        PATCH=${PATCH:-0}

        echo "üìå Current version: v$MAJOR.$MINOR.$PATCH"

        # PR Ï†úÎ™©ÏóêÏÑú Î≤ÑÏ†Ñ Ï¶ùÍ∞Ä ÌÉÄÏûÖ ÌôïÏù∏
        PR_TITLE="${{ github.event.pull_request.title }}"
        echo "üîç PR title: $PR_TITLE"

        # Ï¶ùÍ∞Ä ÌÉÄÏûÖ ÌåêÎ≥Ñ
        if [[ "$PR_TITLE" == *"#major"* ]]; then
          MAJOR=$((MAJOR + 1))
          MINOR=0
          PATCH=0
          INCREMENT_TYPE="major"
        elif [[ "$PR_TITLE" == *"#minor"* ]]; then
          MINOR=$((MINOR + 1))
          PATCH=0
          INCREMENT_TYPE="minor"
        else
          PATCH=$((PATCH + 1))
          INCREMENT_TYPE="patch"
        fi

        NEW_VERSION="dev-v$MAJOR.$MINOR.$PATCH"
        echo "üéØ Bumping $INCREMENT_TYPE version: $LATEST_TAG ‚Üí $NEW_VERSION"

        echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
        echo "new_tag=$NEW_VERSION" >> $GITHUB_OUTPUT

        # ÌÉúÍ∑∏ ÏÉùÏÑ± Î∞è Ìë∏Ïãú
        git tag $NEW_VERSION
        git push origin $NEW_VERSION

    - name: Save .env
      run: echo "${{ secrets.DEV_ENV_CONTENTS }}" > .env

    - name: Change files for dev environment
      run: cp docker-compose.dev.yml docker-compose.yml

    - name: Zip Application
      run: zip -r app.zip . -x ".git/*" ".github/*"

    - name: Upload to S3
      run: |
        aws s3 cp app.zip s3://${{ secrets.DEV_EB_BUCKET }}/app-${{ env.NEW_VERSION }}.zip

    - name: Check if EB environment exists
      id: check_env
      run: |
        ENV_EXISTS=$(aws elasticbeanstalk describe-environments \
          --application-name ${{ secrets.DEV_EB_APPLICATION_NAME }} \
          --environment-names ${{ secrets.DEV_EB_ENV_NAME }} \
          --query "Environments[?Status!='Terminated'].EnvironmentName" \
          --output text || echo "")

        if [ -z "$ENV_EXISTS" ]; then
          echo "Environment does not exist or is terminated"
          echo "env_exists=false" >> $GITHUB_OUTPUT
        else
          echo "Environment exists: $ENV_EXISTS"
          echo "env_exists=true" >> $GITHUB_OUTPUT
        fi

    - name: Create EB environment if not exists
      if: steps.check_env.outputs.env_exists == 'false'
      run: |
        echo "Creating new Elastic Beanstalk environment..."

        # ÏµúÏã† solution stack Í∞ÄÏ†∏Ïò§Í∏∞
        echo "Fetching available solution stacks..."
        SOLUTION_STACK=$(aws elasticbeanstalk list-available-solution-stacks \
          --query 'SolutionStacks[?contains(@, `Docker`)][0]' \
          --output text)

        # ÎßåÏïΩ Ï∞æÏßÄ Î™ªÌñàÎã§Î©¥ Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©
        if [ -z "$SOLUTION_STACK" ] || [ "$SOLUTION_STACK" == "None" ]; then
          echo "Could not find Docker solution stack, using default..."
          SOLUTION_STACK="64bit Amazon Linux 2023 v4.3.0 running Docker"
        fi

        echo "Using solution stack: $SOLUTION_STACK"

        # ÌôòÍ≤Ω ÏÉùÏÑ±
        aws elasticbeanstalk create-environment \
          --application-name ${{ secrets.DEV_EB_APPLICATION_NAME }} \
          --environment-name ${{ secrets.DEV_EB_ENV_NAME }} \
          --solution-stack-name "$SOLUTION_STACK" \
          --version-label ${{ env.NEW_VERSION }} \
          --option-settings \
            Namespace=aws:elasticbeanstalk:environment,OptionName=ServiceRole,Value=${{ secrets.DEV_EB_SERVICE_ROLE }} \
            Namespace=aws:autoscaling:launchconfiguration,OptionName=IamInstanceProfile,Value=${{ secrets.DEV_EB_INSTANCE_PROFILE }} \
            Namespace=aws:elasticbeanstalk:environment,OptionName=LoadBalancerType,Value=application \
            Namespace=aws:elasticbeanstalk:environment:process:default,OptionName=Port,Value=8000 \
            Namespace=aws:elasticbeanstalk:environment:process:default,OptionName=Protocol,Value=HTTP \
            Namespace=aws:elasticbeanstalk:environment:process:default,OptionName=HealthCheckPath,Value=/health \
            Namespace=aws:ec2:vpc,OptionName=VPCId,Value=${{ secrets.DEV_VPC_ID }} \
            Namespace=aws:ec2:vpc,OptionName=Subnets,Value=${{ secrets.DEV_SUBNET_IDS }}

        # ÌôòÍ≤Ω ÏÉùÏÑ± ÏôÑÎ£å ÎåÄÍ∏∞
        echo "Waiting for environment creation..."
        aws elasticbeanstalk wait environment-exists \
          --application-name ${{ secrets.DEV_EB_APPLICATION_NAME }} \
          --environment-names ${{ secrets.DEV_EB_ENV_NAME }}

    - name: Create new Elastic Beanstalk Application Version
      run: |
        aws elasticbeanstalk create-application-version \
          --application-name ${{ secrets.DEV_EB_APPLICATION_NAME }} \
          --version-label ${{ env.NEW_VERSION }} \
          --source-bundle S3Bucket=${{ secrets.DEV_EB_BUCKET }},S3Key=app-${{ env.NEW_VERSION }}.zip

    - name: Wait for EB environment to be Ready
      run: |
        echo "‚è≥ Waiting for environment to become Ready..."
        while [ "$(aws elasticbeanstalk describe-environments \
                        --environment-names ${{ secrets.DEV_EB_ENV_NAME }} \
                        --query "Environments[0].Status" \
                        --output text)" != "Ready" ]; do
          echo "   Current status: $(aws elasticbeanstalk describe-environments \
                                  --environment-names ${{ secrets.DEV_EB_ENV_NAME }} \
                                  --query "Environments[0].Status" \
                                  --output text). Sleeping 15s..."
          sleep 15
        done

    - name: Deploy to Elastic Beanstalk
      run: |
        aws elasticbeanstalk update-environment \
          --environment-name ${{ secrets.DEV_EB_ENV_NAME }} \
          --version-label ${{ env.NEW_VERSION }}

    - name: Post deployment comment
      if: always()
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GH_PAT }}
        script: |
          const { owner, repo } = context.repo;
          const run_id = context.runId;
          const run_url = `https://github.com/${owner}/${repo}/actions/runs/${run_id}`;

          const status = '${{ job.status }}';
          const emoji = status === 'success' ? '‚úÖ' : '‚ùå';
          const message = status === 'success'
            ? `Dev deployment completed successfully! Version: ${{ env.NEW_VERSION }}`
            : 'Dev deployment failed!';

          // PR Ïù¥Î≤§Ìä∏Ïùº ÎïåÎßå ÏΩîÎ©òÌä∏ ÏûëÏÑ±
          if (context.eventName === 'pull_request') {
            try {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: context.issue.number,
                body: `${emoji} ${message}\n\n[View deployment logs](${run_url})`
              });
            } catch (error) {
              console.log('Failed to create comment:', error.message);
              // ÏΩîÎ©òÌä∏ Ïã§Ìå®Îäî Î¨¥ÏãúÌïòÍ≥† ÏßÑÌñâ
            }
          }
