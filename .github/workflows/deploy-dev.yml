# name: Deploy to Dev Environment

# on:
#   pull_request:
#     types: [closed]
#     branches:
#       - dev

# jobs:
#   deploy:
#     if: github.event.pull_request.merged == true
#     runs-on: ubuntu-latest
#     env:
#       GH_PAT: ${{ secrets.GH_PAT }}

#     steps:
#       - name: Checkout Repository
#         uses: actions/checkout@v4
#         with:
#           fetch-depth: 0

#       - name: Configure AWS Credentials
#         uses: aws-actions/configure-aws-credentials@v4
#         with:
#           aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#           aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#           aws-region: ${{ secrets.AWS_REGION }}

#       - name: Bump version from latest tag (supports #major #minor)
#         id: versioning
#         env:
#           GH_PAT: ${{ secrets.GH_PAT }}
#         run: |
#           # ë¨¼ì € ì¸ì¦ëœ remoteë¡œ ë®ì–´ì“°ê¸°
#           git config --global user.name "github-actions"
#           git config --global user.email "github-actions@github.com"

#           git config --unset-all http.https://github.com/.extraheader || true

#           git remote set-url origin https://x-access-token:${GH_PAT}@github.com/${{ github.repository }}.git

#           # ì´í›„ fetchëŠ” PAT ì¸ì¦ ê¸°ë°˜ìœ¼ë¡œ ìˆ˜í–‰ë¨
#           git fetch --tags

#           # ìµœì‹  íƒœê·¸ ì¶”ì¶œ (dev íƒœê·¸ í•„í„°ë§)
#           LATEST_TAG=$(git tag -l "dev-v*" --sort=-version:refname | head -n 1)

#           # íƒœê·¸ê°€ ì—†ìœ¼ë©´ ì´ˆê¸°ê°’ ì„¤ì •
#           if [ -z "$LATEST_TAG" ]; then
#             echo "No existing dev tags found. Starting from dev-v0.0.0"
#             LATEST_TAG="dev-v0.0.0"
#           fi

#           VERSION=${LATEST_TAG#dev-v}
#           IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

#           # ë²„ì „ êµ¬ì„±ìš”ì†Œê°€ ë¹„ì–´ìˆìœ¼ë©´ 0ìœ¼ë¡œ ì„¤ì •
#           MAJOR=${MAJOR:-0}
#           MINOR=${MINOR:-0}
#           PATCH=${PATCH:-0}

#           echo "ğŸ“Œ Current version: v$MAJOR.$MINOR.$PATCH"

#           # PR ì œëª©ì—ì„œ ë²„ì „ ì¦ê°€ íƒ€ì… í™•ì¸
#           PR_TITLE="${{ github.event.pull_request.title }}"
#           echo "ğŸ” PR title: $PR_TITLE"

#           # ì¦ê°€ íƒ€ì… íŒë³„
#           if [[ "$PR_TITLE" == *"#major"* ]]; then
#             MAJOR=$((MAJOR + 1))
#             MINOR=0
#             PATCH=0
#             INCREMENT_TYPE="major"
#           elif [[ "$PR_TITLE" == *"#minor"* ]]; then
#             MINOR=$((MINOR + 1))
#             PATCH=0
#             INCREMENT_TYPE="minor"
#           else
#             PATCH=$((PATCH + 1))
#             INCREMENT_TYPE="patch"
#           fi

#           NEW_VERSION="dev-v$MAJOR.$MINOR.$PATCH"
#           echo "ğŸ¯ Bumping $INCREMENT_TYPE version: $LATEST_TAG â†’ $NEW_VERSION"

#           echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
#           echo "new_tag=$NEW_VERSION" >> $GITHUB_OUTPUT

#           # íƒœê·¸ ìƒì„± ë° í‘¸ì‹œ
#           git tag $NEW_VERSION
#           git push origin $NEW_VERSION

#       - name: Save .env
#         run: echo "${{ secrets.DEV_ENV_CONTENTS }}" > .env

#       - name: Change files for dev environment
#         run: cp docker-compose.dev.yml docker-compose.yml

#       - name: Zip Application
#         run: zip -r app.zip . -x ".git/*" ".github/*"

#       - name: Upload to S3
#         run: |
#           aws s3 cp app.zip s3://${{ secrets.DEV_EB_BUCKET }}/app-${{ env.NEW_VERSION }}.zip

#       - name: Verify EB environment is ready
#         run: |
#           echo "Verifying Elastic Beanstalk environment status..."
#           ENV_STATUS=$(aws elasticbeanstalk describe-environments \
#             --application-name ${{ secrets.DEV_EB_APPLICATION_NAME }} \
#             --environment-names ${{ secrets.DEV_EB_ENV_NAME }} \
#             --query "Environments[0].Status" \
#             --output text 2>/dev/null || echo "NOT_FOUND")

#           if [ "$ENV_STATUS" = "NOT_FOUND" ] || [ "$ENV_STATUS" = "None" ]; then
#             echo "âŒ Environment not found. Please run 'make apply-dev' first."
#             exit 1
#           fi

#           echo "âœ… Environment status: $ENV_STATUS"

#       - name: Create new Elastic Beanstalk Application Version
#         run: |
#           aws elasticbeanstalk create-application-version \
#             --application-name ${{ secrets.DEV_EB_APPLICATION_NAME }} \
#             --version-label ${{ env.NEW_VERSION }} \
#             --source-bundle S3Bucket=${{ secrets.DEV_EB_BUCKET }},S3Key=app-${{ env.NEW_VERSION }}.zip

#       - name: Deploy to Elastic Beanstalk
#         run: |
#           echo "ğŸš€ Deploying new version to Elastic Beanstalk..."
#           aws elasticbeanstalk update-environment \
#             --environment-name ${{ secrets.DEV_EB_ENV_NAME }} \
#             --version-label ${{ env.NEW_VERSION }}

#       - name: Wait for deployment completion
#         run: |
#           echo "â³ Waiting for deployment to complete..."

#           # ìµœëŒ€ 15ë¶„ ëŒ€ê¸° (60 * 15 = 900ì´ˆ)
#           MAX_ATTEMPTS=60
#           ATTEMPT=0

#           while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
#             ENV_STATUS=$(aws elasticbeanstalk describe-environments \
#               --environment-names ${{ secrets.DEV_EB_ENV_NAME }} \
#               --query "Environments[0].Status" \
#               --output text)

#             ENV_HEALTH=$(aws elasticbeanstalk describe-environments \
#               --environment-names ${{ secrets.DEV_EB_ENV_NAME }} \
#               --query "Environments[0].Health" \
#               --output text)

#             echo "Status: $ENV_STATUS, Health: $ENV_HEALTH"

#             # Ready ìƒíƒœì´ê³  Updatingì´ ì•„ë‹ˆë©´ ì™„ë£Œ
#             if [ "$ENV_STATUS" = "Ready" ]; then
#               echo "âœ… Deployment completed! Final health: $ENV_HEALTH"
#               break
#             fi

#             # ì‹¬ê°í•œ ì˜¤ë¥˜ ìƒíƒœë©´ ì¤‘ë‹¨
#             if [ "$ENV_STATUS" = "Terminating" ] || [ "$ENV_STATUS" = "Terminated" ]; then
#               echo "âŒ Environment is in error state: $ENV_STATUS"
#               exit 1
#             fi

#             ATTEMPT=$((ATTEMPT + 1))
#             echo "   Attempt $ATTEMPT/$MAX_ATTEMPTS - Waiting 15s..."
#             sleep 15
#           done

#           if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
#             echo "âš ï¸  Deployment timeout after 15 minutes, but this is normal for initial deployments"
#             echo "   Check AWS Console for deployment progress"
#           fi

#       - name: Post deployment comment
#         if: always()
#         uses: actions/github-script@v7
#         with:
#           github-token: ${{ secrets.GH_PAT }}
#           script: |
#             const { owner, repo } = context.repo;
#             const run_id = context.runId;
#             const run_url = `https://github.com/${owner}/${repo}/actions/runs/${run_id}`;

#             const status = '${{ job.status }}';
#             const emoji = status === 'success' ? 'âœ…' : 'âŒ';
#             const message = status === 'success'
#               ? `Dev deployment completed successfully! Version: ${{ env.NEW_VERSION }}`
#               : 'Dev deployment failed!';

#             // PR ì´ë²¤íŠ¸ì¼ ë•Œë§Œ ì½”ë©˜íŠ¸ ì‘ì„±
#             if (context.eventName === 'pull_request') {
#               try {
#                 await github.rest.issues.createComment({
#                   owner,
#                   repo,
#                   issue_number: context.issue.number,
#                   body: `${emoji} ${message}\n\n[View deployment logs](${run_url})`
#                 });
#               } catch (error) {
#                 console.log('Failed to create comment:', error.message);
#                 // ì½”ë©˜íŠ¸ ì‹¤íŒ¨ëŠ” ë¬´ì‹œí•˜ê³  ì§„í–‰
#               }
#             }
